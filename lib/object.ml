open Yojson.Basic.Util

(** The [object] is a shape that exists
    in the scene and has properties. *)
type t =
  | Sphere of
    { radius: float; center: Vector.t; material: Material.t }
  | Triangle of 
    { vertices: Vector.t * Vector.t * Vector.t; material: Material.t }

let create_sphere radius center material = Sphere { radius; center; material }

let create_triangle vertices material = Triangle { vertices; material }

(* TODO: clean this up *)
let from_json json =
  match json |> member "type" |> to_string with 
  | "sphere" -> Sphere {
      radius = json |> member "radius" |> to_float;
      material = json |> member "material" |> Material.from_json;
      center = json |> member "center" |> Vector.from_json;
    }
  | "triangle" -> Triangle {
      vertices = (json |> member "vertex1" |> Vector.from_json, 
                  json |> member "vertex2" |> Vector.from_json, 
                  json |> member "vertex3" |> Vector.from_json);
      material = json |> member "material" |> Material.from_json;
    }
  | _ -> failwith "unknown object type"

let mat = function 
  | Sphere { material; _ } -> material
  | Triangle { material; _ } -> material

(** [hit_from_t center t mat ray] is the hit from intersecting a sphere
  with [center] and [mat] [t] along [ray] *)
let hit_from_t center t mat ray =
  let point = Vector.add (Ray.origin ray) 
      (Vector.mult_constant (Ray.dir ray) t) in
  let normal = center |> Vector.minus point |> Vector.unit_vector in
  Hit.create t point normal (Ray.dir ray) mat

(** [intersect_sphere radius center mat ray] is the Hit generated by
  intersecting a sphere defined by [radius], [center], and [mat] with [ray] *)
let intersect_sphere radius center mat ray =
  let d = Ray.dir ray in
  let p = Vector.minus (Ray.origin ray) center in

  let a = Vector.dot_prod d d in
  let b = 2. *. (Vector.dot_prod p d) in
  let c = (Vector.dot_prod p p) -. (radius *. radius) in

  let dt2 = (b *. b) -. (4. *. a *. c) in

  if dt2 < 0. then 
    None
  else 
    let dt = Float.sqrt dt2 in

    let t0 = (-.(b +. dt)) /. (2. *. a) in
    let t1 = (-.(b -. dt)) /. (2. *. a) in
    if Ray.in_bounds t0 ray then
      Some (hit_from_t center t0 mat ray)
    else if Ray.in_bounds t1 ray then
      Some (hit_from_t center t1 mat ray)
    else None

(** [intersect_triangle vertices mat ray] is the Hit generated by
  intersecting a triangle defined by [vertices] and [mat] with [ray] *)
let intersect_triangle (a, b, c) mat ray =
  let d = Ray.dir ray in
  let p = Ray.origin ray in

  let offset_p = Vector.minus a p in
  let side_b = Vector.minus a b in
  let side_c = Vector.minus a c in

  let factor = Vector.det side_b side_c d in

  let beta = Vector.det offset_p side_c d /. factor in
  let gamma = Vector.det side_b offset_p d /. factor in
  let t = Vector.det side_b side_c offset_p /. factor in

  if beta < 0.0 || gamma < 0.0 || beta +. gamma > 1.0 then
    None
  else if not (Ray.in_bounds t ray) then
    None
  else
    let point = t |> Vector.mult_constant d |> Vector.add p in
    let dir = Vector.cross_prod side_b side_c in
    let normal = -1.0
      |> Vector.mult_constant offset_p
      |> Vector.dot_prod dir
      |> Vector.mult_constant dir
      |> Vector.unit_vector
    in
    Some (Hit.create t point normal d mat)

let intersect ray = function
  | Sphere { radius; center; material } -> 
    intersect_sphere radius center material ray
  | Triangle { vertices; material; } -> 
    intersect_triangle vertices material ray
